# Теория к Лабораторной работе №4: Сложные запросы SQL

В этой лабораторной работе рассматриваются продвинутые методы извлечения и обработки данных в реляционных базах данных. Мы переходим от простых `SELECT ... FROM ... WHERE` к аналитическим запросам, объединению множества таблиц и использованию оконных функций.

---

## 1. Соединения таблиц (JOINs)

Реляционные базы данных нормализованы, то есть данные разнесены по разным таблицам, чтобы избежать дублирования. `JOIN` — это механизм, позволяющий собрать данные из нескольких таблиц в единый результирующий набор.

### Фундаментальные типы соединений

| Тип JOIN | Описание | Аналогия с теорией множеств |
| :--- | :--- | :--- |
| **INNER JOIN** | Возвращает только те строки, для которых найдено соответствие в **обеих** таблицах. Если соответствия нет, строка не попадает в результат. | Пересечение множеств ($A \cap B$) |
| **LEFT JOIN** | Возвращает **все** строки из левой таблицы (первой указанной) и соответствующие строки из правой. Если совпадения нет, поля правой таблицы заполняются `NULL`. | Левое множество ($A$) |
| **RIGHT JOIN** | Зеркально LEFT JOIN: все строки из правой таблицы и совпадения из левой. Редко используется на практике, так как обычно заменяется на LEFT JOIN с перестановкой таблиц. | Правое множество ($B$) |
| **FULL JOIN** | Возвращает строки, если есть совпадение в **любой** из таблиц. Если совпадения нет, недостающие поля — `NULL`. | Объединение множеств ($A \cup B$) |
| **CROSS JOIN** | Декартово произведение. Каждая строка первой таблицы соединяется с каждой строкой второй таблицы. Если в таблице A $N$ строк, а в B $M$ строк, результат будет $N \times M$. | Декартово произведение ($A \times B$) |

### Пример (HomeFlip)
Допустим, мы хотим получить список предложений обмена (`offers`) с названиями жилья (`accommodations`).

```sql
SELECT a.title, o.price
FROM accommodations a
INNER JOIN offers o ON a.id = o.accommodation_id;
```
*Если у жилья нет активного предложения, оно не попадет в выборку.*

Если мы хотим видеть **все** жилье, даже если на него нет предложений:
```sql
SELECT a.title, o.price
FROM accommodations a
LEFT JOIN offers o ON a.id = o.accommodation_id;
```
*В строках без предложений поле `price` будет `NULL`.*

---

## 2. Вложенные запросы (Subqueries)

Подзапрос — это запрос внутри другого запроса.

### Классификация по возвращаемому результату
1.  **Скалярный подзапрос**: Возвращает одно значение (1 строка, 1 столбец). Можно использовать там, где ожидается число или строка (например, в `SELECT` или сравнении `>`).
2.  **Табличный подзапрос**: Возвращает список значений или таблицу. Используется в `IN`, `EXISTS` или в секции `FROM`.

### Коррелированные подзапросы
Это подзапросы, которые ссылаются на столбцы внешнего запроса. Они выполняются **для каждой строки** внешнего запроса, что может быть медленно.

**Пример:** Найти жилье, цена которого выше средней цены по *этому же* городу.
```sql
SELECT a1.title, a1.price, a1.city_id
FROM accommodations a1
WHERE a1.price > (
    SELECT AVG(a2.price)
    FROM accommodations a2
    WHERE a2.city_id = a1.city_id -- Ссылка на внешний запрос
);
```

### EXISTS vs IN
*   `IN`: Проверяет наличие значения в списке. Удобно для небольших списков.
*   `EXISTS`: Проверяет, возвращает ли подзапрос хотя бы одну строку. Обычно эффективнее `IN` при работе с большими объемами данных, так как проверка прекращается после первого совпадения.

---

## 3. Группировка и Агрегация (GROUP BY)

Позволяет объединять строки с одинаковыми значениями в группы и вычислять для них агрегатные значения.

**Порядок выполнения:**
1.  `FROM` + `JOIN` (сбор данных)
2.  `WHERE` (фильтрация строк)
3.  `GROUP BY` (группировка)
4.  `HAVING` (фильтрация **групп**)
5.  `SELECT` (выбор столбцов)
6.  `ORDER BY` (сортировка)

**Важно:** В `SELECT` при наличии `GROUP BY` можно указывать только:
*   Столбцы, перечисленные в `GROUP BY`.
*   Агрегатные функции (`COUNT`, `SUM`, `AVG`, `MIN`, `MAX`).

**Пример:** Показать города, где более 5 объектов жилья.
```sql
SELECT city_id, COUNT(*) as cnt
FROM accommodations
GROUP BY city_id
HAVING COUNT(*) > 5;
```

---

## 4. Оконные функции (Window Functions)

Это мощный инструмент аналитики. В отличие от `GROUP BY`, оконные функции **не схлопывают** строки в одну. Они позволяют вычислять агрегаты "поверх" строк, сохраняя исходное количество строк.

Синтаксис:
```sql
FUNCTION_NAME() OVER (
    PARTITION BY column1    -- Как делить данные на "окна" (группы)
    ORDER BY column2        -- Как сортировать внутри окна
    ROWS ...                -- (Опционально) рамки окна
)
```

### Популярные функции
*   `ROW_NUMBER()`: Порядковый номер строки в окне.
*   `RANK()`: Ранг (с пропусками: 1, 1, 3...).
*   `DENSE_RANK()`: Плотный ранг (без пропусков: 1, 1, 2...).
*   `LAG(col, n)` / `LEAD(col, n)`: Значение из предыдущей / следующей строки.

**Пример:** Вывести список жилья и его ранг по цене внутри каждого города.
```sql
SELECT 
    title, 
    city_id, 
    price,
    DENSE_RANK() OVER (PARTITION BY city_id ORDER BY price DESC) as rank_in_city
FROM accommodations;
```

---

## 5. Представления (Views)

`VIEW` (Представление) — это сохраненный SQL-запрос, к которому можно обращаться как к виртуальной таблице.

**Зачем нужны:**
1.  **Абстракция:** Скрытие сложности (многоэтажные JOIN-ы прячутся за одним именем).
2.  **Безопасность:** Можно дать пользователю доступ к View, но не к исходным таблицам (например, скрыть колонку с паролями).
3.  **Переиспользование:** Не нужно переписывать сложный запрос каждый раз.

```sql
CREATE VIEW active_offers_view AS
SELECT o.id, a.title, u.email
FROM offers o
JOIN accommodations a ON o.accommodation_id = a.id
JOIN users u ON a.owner_id = u.id
WHERE o.status = 'active';
```

---

## 6. CTE (Common Table Expressions)

Конструкция `WITH` позволяет создавать временные именованные наборы данных, существующие только в рамках одного запроса. Это делает код более читаемым по сравнению с вложенными подзапросами.

```sql
WITH CityStats AS (
    SELECT city_id, AVG(price) as avg_price
    FROM accommodations
    GROUP BY city_id
)
SELECT a.title, a.price, cs.avg_price
FROM accommodations a
JOIN CityStats cs ON a.city_id = cs.city_id
WHERE a.price < cs.avg_price;
```
